<div id="readability-page-1" class="page"><div>
		<meta charset="utf-8">
		<base href="../../../">
		
		
	
	
		<h2>How to use post-processing</h2>

		<p>
			Many three.js applications render their 3D objects directly to the screen. Sometimes, however, you want to apply one or more graphical
			effects like Depth-Of-Field, Bloom, Film Grain or various types of Anti-aliasing. Post-processing is a widely used approach
			to implement such effects. First, the scene is rendered to a render target which represents a buffer in the video card's memory.
			In the next step one or more post-processing passes apply filters and effects to the image buffer before it is eventually rendered to
			the screen.
		</p>
		<p>
			three.js provides a complete post-processing solution via <a data-fragment="EffectComposer" title="EffectComposer" href="https://threejs.org/docs/index.html#examples/en/postprocessing/EffectComposer">EffectComposer</a> to implement such a workflow.
		</p>

		<h2>Workflow</h2>

		<p>
			The first step in the process is to import all necessary files from the examples directory. The guide assumes you are using the official
			<a href="https://www.npmjs.com/package/three" target="_blank">npm package</a> of three.js. For our basic demo in this guide we need the following files.
		</p>

		<p><code translate="no"><span>import</span><span> </span><span>{</span><span> </span><span>EffectComposer</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>'three/addons/postprocessing/EffectComposer.js'</span><span>;</span><span>
</span><span>import</span><span> </span><span>{</span><span> </span><span>RenderPass</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>'three/addons/postprocessing/RenderPass.js'</span><span>;</span><span>
</span><span>import</span><span> </span><span>{</span><span> </span><span>GlitchPass</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>'three/addons/postprocessing/GlitchPass.js'</span><span>;</span><span>
</span><span>import</span><span> </span><span>{</span><span> </span><span>OutputPass</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>'three/addons/postprocessing/OutputPass.js'</span><span>;</span></code></p><p>
			After all files are successfully imported, we can create our composer by passing in an instance of <a data-fragment="WebGLRenderer" title="WebGLRenderer" href="https://threejs.org/docs/index.html#api/en/renderers/WebGLRenderer">WebGLRenderer</a>.
		</p>

		<p><code translate="no"><span>const</span><span> composer </span><span>=</span><span> </span><span>new</span><span> </span><span>EffectComposer</span><span>(</span><span> renderer </span><span>);</span></code></p><p>
			When using a composer, it's necessary to change the application's animation loop. Instead of calling the render method of
			<a data-fragment="WebGLRenderer" title="WebGLRenderer" href="https://threejs.org/docs/index.html#api/en/renderers/WebGLRenderer">WebGLRenderer</a>, we now use the respective counterpart of <a data-fragment="EffectComposer" title="EffectComposer" href="https://threejs.org/docs/index.html#examples/en/postprocessing/EffectComposer">EffectComposer</a>.
		</p>

		<p><code translate="no"><span>function</span><span> animate</span><span>()</span><span> </span><span>{</span><span>

	requestAnimationFrame</span><span>(</span><span> animate </span><span>);</span><span>

	composer</span><span>.</span><span>render</span><span>();</span><span>

</span><span>}</span></code></p><p>
			Our composer is now ready so it's possible to configure the chain of post-processing passes. These passes are responsible for creating
			the final visual output of the application. They are processed in order of their addition/insertion. In our example, the instance of <code translate="no"><span>RenderPass</span></code>
			is executed first, then the instance of <code translate="no"><span>GlitchPass</span></code> and finally <code translate="no"><span>OutputPass</span></code>. The last enabled pass in the chain is automatically rendered to the screen. 
			The setup of the passes looks like so:
		</p>

		<p><code translate="no"><span>const</span><span> renderPass </span><span>=</span><span> </span><span>new</span><span> </span><span>RenderPass</span><span>(</span><span> scene</span><span>,</span><span> camera </span><span>);</span><span>
composer</span><span>.</span><span>addPass</span><span>(</span><span> renderPass </span><span>);</span><span>

</span><span>const</span><span> glitchPass </span><span>=</span><span> </span><span>new</span><span> </span><span>GlitchPass</span><span>();</span><span>
composer</span><span>.</span><span>addPass</span><span>(</span><span> glitchPass </span><span>);</span><span>

</span><span>const</span><span> outputPass </span><span>=</span><span> </span><span>new</span><span> </span><span>OutputPass</span><span>();</span><span>
composer</span><span>.</span><span>addPass</span><span>(</span><span> outputPass </span><span>);</span></code></p><p>
			<code translate="no"><span>RenderPass</span></code> is normally placed at the beginning of the chain in order to provide the rendered scene as an input for the next post-processing step. In our case,
			<code translate="no"><span>GlitchPass</span></code> is going to use these image data to apply a wild glitch effect. <code translate="no"><span>OutputPass</span></code> is usually the last pass in the chain which performs sRGB color space conversion and tone mapping.
			Check out this <a href="https://threejs.org/examples/webgl_postprocessing_glitch" target="_blank">live example</a> to see it in action.
		</p>

		<h2>Built-in Passes</h2>

		<p>
			You can use a wide range of pre-defined post-processing passes provided by the engine. They are located in the
			<a href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing" target="_blank">postprocessing</a> directory.
		</p>

		<h2>Custom Passes</h2>

		<p>
			Sometimes you want to write a custom post-processing shader and include it into the chain of post-processing passes. For this scenario,
			you can utilize <code translate="no"><span>ShaderPass</span></code>. After importing the file and your custom shader, you can use the following code to setup the pass.
		</p>

		<p><code translate="no"><span>import</span><span> </span><span>{</span><span> </span><span>ShaderPass</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>'three/addons/postprocessing/ShaderPass.js'</span><span>;</span><span>
</span><span>import</span><span> </span><span>{</span><span> </span><span>LuminosityShader</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>'three/addons/shaders/LuminosityShader.js'</span><span>;</span><span>

</span><span>// later in your init routine</span><span>

</span><span>const</span><span> luminosityPass </span><span>=</span><span> </span><span>new</span><span> </span><span>ShaderPass</span><span>(</span><span> </span><span>LuminosityShader</span><span> </span><span>);</span><span>
composer</span><span>.</span><span>addPass</span><span>(</span><span> luminosityPass </span><span>);</span></code></p><p>
			The repository provides a file called <a href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/shaders/CopyShader.js" target="_blank">CopyShader</a> which is a
			good starting code for your own custom shader. <code translate="no"><span>CopyShader</span></code> just copies the image contents of the <a data-fragment="EffectComposer" title="EffectComposer" href="https://threejs.org/docs/index.html#examples/en/postprocessing/EffectComposer">EffectComposer</a>'s read buffer
			to its write buffer without applying any effects.
		</p>

	

<p><img src="https://threejs.org/files/ic_mode_edit_black_24dp.svg"></p></div></div>