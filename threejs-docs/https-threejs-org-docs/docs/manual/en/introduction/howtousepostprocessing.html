<!DOCTYPE html><html><head><title>Post-processing â€“ three.js docs</title></head><body><body>
		<h1>How to use post-processing</h1>

		<p>
			Many three.js applications render their 3D objects directly to the screen. Sometimes, however, you want to apply one or more graphical
			effects like Depth-Of-Field, Bloom, Film Grain or various types of Anti-aliasing. Post-processing is a widely used approach
			to implement such effects. First, the scene is rendered to a render target which represents a buffer in the video card's memory.
			In the next step one or more post-processing passes apply filters and effects to the image buffer before it is eventually rendered to
			the screen.
		</p>
		<p>
			three.js provides a complete post-processing solution via <a class=/"links/" data-fragment=/"EffectComposer/" title=/"EffectComposer/" href=/"./index.html#examples/en/postprocessing/EffectComposer/">EffectComposer</a> to implement such a workflow.
		</p>

		<h2>Workflow</h2>

		<p>
			The first step in the process is to import all necessary files from the examples directory. The guide assumes you are using the official
			<a href=/"https://www.npmjs.com/package/three/" target=/"_blank/">npm package</a> of three.js. For our basic demo in this guide we need the following files.
		</p>

		<code class=/" prettyprint/" translate=/"no/"><span class=/"kwd/">import</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/"> </span><span class=/"typ/">EffectComposer</span><span class=/"pln/"> </span><span class=/"pun/">}</span><span class=/"pln/"> </span><span class=/"kwd/">from</span><span class=/"pln/"> </span><span class=/"str/">'three/addons/postprocessing/EffectComposer.js'</span><span class=/"pun/">;</span><span class=/"pln/">
</span><span class=/"kwd/">import</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/"> </span><span class=/"typ/">RenderPass</span><span class=/"pln/"> </span><span class=/"pun/">}</span><span class=/"pln/"> </span><span class=/"kwd/">from</span><span class=/"pln/"> </span><span class=/"str/">'three/addons/postprocessing/RenderPass.js'</span><span class=/"pun/">;</span><span class=/"pln/">
</span><span class=/"kwd/">import</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/"> </span><span class=/"typ/">GlitchPass</span><span class=/"pln/"> </span><span class=/"pun/">}</span><span class=/"pln/"> </span><span class=/"kwd/">from</span><span class=/"pln/"> </span><span class=/"str/">'three/addons/postprocessing/GlitchPass.js'</span><span class=/"pun/">;</span><span class=/"pln/">
</span><span class=/"kwd/">import</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/"> </span><span class=/"typ/">OutputPass</span><span class=/"pln/"> </span><span class=/"pun/">}</span><span class=/"pln/"> </span><span class=/"kwd/">from</span><span class=/"pln/"> </span><span class=/"str/">'three/addons/postprocessing/OutputPass.js'</span><span class=/"pun/">;</span></code>

		<p>
			After all files are successfully imported, we can create our composer by passing in an instance of <a class=/"links/" data-fragment=/"WebGLRenderer/" title=/"WebGLRenderer/" href=/"./index.html#api/en/renderers/WebGLRenderer/">WebGLRenderer</a>.
		</p>

		<code class=/" prettyprint/" translate=/"no/"><span class=/"kwd/">const</span><span class=/"pln/"> composer </span><span class=/"pun/">=</span><span class=/"pln/"> </span><span class=/"kwd/">new</span><span class=/"pln/"> </span><span class=/"typ/">EffectComposer</span><span class=/"pun/">(</span><span class=/"pln/"> renderer </span><span class=/"pun/">);</span></code>

		<p>
			When using a composer, it's necessary to change the application's animation loop. Instead of calling the render method of
			<a class=/"links/" data-fragment=/"WebGLRenderer/" title=/"WebGLRenderer/" href=/"./index.html#api/en/renderers/WebGLRenderer/">WebGLRenderer</a>, we now use the respective counterpart of <a class=/"links/" data-fragment=/"EffectComposer/" title=/"EffectComposer/" href=/"./index.html#examples/en/postprocessing/EffectComposer/">EffectComposer</a>.
		</p>

		<code class=/" prettyprint/" translate=/"no/"><span class=/"kwd/">function</span><span class=/"pln/"> animate</span><span class=/"pun/">()</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/">

	requestAnimationFrame</span><span class=/"pun/">(</span><span class=/"pln/"> animate </span><span class=/"pun/">);</span><span class=/"pln/">

	composer</span><span class=/"pun/">.</span><span class=/"pln/">render</span><span class=/"pun/">();</span><span class=/"pln/">

</span><span class=/"pun/">}</span></code>

		<p>
			Our composer is now ready so it's possible to configure the chain of post-processing passes. These passes are responsible for creating
			the final visual output of the application. They are processed in order of their addition/insertion. In our example, the instance of <code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">RenderPass</span></code>
			is executed first, then the instance of <code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">GlitchPass</span></code> and finally <code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">OutputPass</span></code>. The last enabled pass in the chain is automatically rendered to the screen. 
			The setup of the passes looks like so:
		</p>

		<code class=/" prettyprint/" translate=/"no/"><span class=/"kwd/">const</span><span class=/"pln/"> renderPass </span><span class=/"pun/">=</span><span class=/"pln/"> </span><span class=/"kwd/">new</span><span class=/"pln/"> </span><span class=/"typ/">RenderPass</span><span class=/"pun/">(</span><span class=/"pln/"> scene</span><span class=/"pun/">,</span><span class=/"pln/"> camera </span><span class=/"pun/">);</span><span class=/"pln/">
composer</span><span class=/"pun/">.</span><span class=/"pln/">addPass</span><span class=/"pun/">(</span><span class=/"pln/"> renderPass </span><span class=/"pun/">);</span><span class=/"pln/">

</span><span class=/"kwd/">const</span><span class=/"pln/"> glitchPass </span><span class=/"pun/">=</span><span class=/"pln/"> </span><span class=/"kwd/">new</span><span class=/"pln/"> </span><span class=/"typ/">GlitchPass</span><span class=/"pun/">();</span><span class=/"pln/">
composer</span><span class=/"pun/">.</span><span class=/"pln/">addPass</span><span class=/"pun/">(</span><span class=/"pln/"> glitchPass </span><span class=/"pun/">);</span><span class=/"pln/">

</span><span class=/"kwd/">const</span><span class=/"pln/"> outputPass </span><span class=/"pun/">=</span><span class=/"pln/"> </span><span class=/"kwd/">new</span><span class=/"pln/"> </span><span class=/"typ/">OutputPass</span><span class=/"pun/">();</span><span class=/"pln/">
composer</span><span class=/"pun/">.</span><span class=/"pln/">addPass</span><span class=/"pun/">(</span><span class=/"pln/"> outputPass </span><span class=/"pun/">);</span></code>

		<p>
			<code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">RenderPass</span></code> is normally placed at the beginning of the chain in order to provide the rendered scene as an input for the next post-processing step. In our case,
			<code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">GlitchPass</span></code> is going to use these image data to apply a wild glitch effect. <code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">OutputPass</span></code> is usually the last pass in the chain which performs sRGB color space conversion and tone mapping.
			Check out this <a href=/"https://threejs.org/examples/webgl_postprocessing_glitch/" target=/"_blank/">live example</a> to see it in action.
		</p>

		<h2>Built-in Passes</h2>

		<p>
			You can use a wide range of pre-defined post-processing passes provided by the engine. They are located in the
			<a href=/"https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing/" target=/"_blank/">postprocessing</a> directory.
		</p>

		<h2>Custom Passes</h2>

		<p>
			Sometimes you want to write a custom post-processing shader and include it into the chain of post-processing passes. For this scenario,
			you can utilize <code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">ShaderPass</span></code>. After importing the file and your custom shader, you can use the following code to setup the pass.
		</p>

		<code class=/" prettyprint/" translate=/"no/"><span class=/"kwd/">import</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/"> </span><span class=/"typ/">ShaderPass</span><span class=/"pln/"> </span><span class=/"pun/">}</span><span class=/"pln/"> </span><span class=/"kwd/">from</span><span class=/"pln/"> </span><span class=/"str/">'three/addons/postprocessing/ShaderPass.js'</span><span class=/"pun/">;</span><span class=/"pln/">
</span><span class=/"kwd/">import</span><span class=/"pln/"> </span><span class=/"pun/">{</span><span class=/"pln/"> </span><span class=/"typ/">LuminosityShader</span><span class=/"pln/"> </span><span class=/"pun/">}</span><span class=/"pln/"> </span><span class=/"kwd/">from</span><span class=/"pln/"> </span><span class=/"str/">'three/addons/shaders/LuminosityShader.js'</span><span class=/"pun/">;</span><span class=/"pln/">

</span><span class=/"com/">// later in your init routine</span><span class=/"pln/">

</span><span class=/"kwd/">const</span><span class=/"pln/"> luminosityPass </span><span class=/"pun/">=</span><span class=/"pln/"> </span><span class=/"kwd/">new</span><span class=/"pln/"> </span><span class=/"typ/">ShaderPass</span><span class=/"pun/">(</span><span class=/"pln/"> </span><span class=/"typ/">LuminosityShader</span><span class=/"pln/"> </span><span class=/"pun/">);</span><span class=/"pln/">
composer</span><span class=/"pun/">.</span><span class=/"pln/">addPass</span><span class=/"pun/">(</span><span class=/"pln/"> luminosityPass </span><span class=/"pun/">);</span></code>

		<p>
			The repository provides a file called <a href=/"https://github.com/mrdoob/three.js/blob/master/examples/jsm/shaders/CopyShader.js/" target=/"_blank/">CopyShader</a> which is a
			good starting code for your own custom shader. <code class=/"inline prettyprint/" translate=/"no/"><span class=/"typ/">CopyShader</span></code> just copies the image contents of the <a class=/"links/" data-fragment=/"EffectComposer/" title=/"EffectComposer/" href=/"./index.html#examples/en/postprocessing/EffectComposer/">EffectComposer</a>'s read buffer
			to its write buffer without applying any effects.
		</p>

	

<div id=/"button/"><img src=/"../files/ic_mode_edit_black_24dp.svg/"></div></body></body></html>